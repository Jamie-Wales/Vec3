
\documentclass[a4paper, oneside, 11pt]{report}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{epsfig,pifont,float,multirow,amsmath,amssymb}
\newcommand{\mc}{\multicolumn{1}{c|}}
\newcommand{\mb}{\mathbf}
\newcommand{\mi}{\mathit}
\newcommand{\oa}{\overrightarrow}
\newcommand{\bs}{\boldsymbol}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\usepackage{algorithm}
\usepackage{natbib}
\usepackage{algpseudocode}
\topmargin = 0pt
\voffset = -80pt
\oddsidemargin = 15pt
\textwidth = 425pt
\textheight = 750pt

\begin{document}

\begin{titlepage}
\begin{center}
\rule{12cm}{1mm} \\
\vspace{1cm}
{\large  CMP-6048A/7009A Advanced Programming} %Delete as appropriate
\vspace{7.5cm}
\\{\Large Project Report - 13 January 2025}
\vspace{1.5cm}
\\{\LARGE Vec3 Maths Bytecode Interpreter} % You can add to this title of modify it if you wish
\vspace{1.0cm}
\\{\Large Group members: \\ Jamie Wales, Jacob Edwards.\ }
\vspace{10.0cm}
\\{\large School of Computing Sciences, University of East Anglia}
\\ \rule{12cm}{0.5mm}
\\ \hspace{8.5cm} {\large Version 2.0}
\end{center}
\end{titlepage}


\setcounter{page}{1}

\begin{abstract}
Vec3 is a bytecode interpreted maths language complete with a GUI, plotting, full static type inference and various 
maths functions.

The language is designed to be simple to use and understand, with a focus on strict mathematical expressions and 
plotting, but with more powerful constructs such as recursive bindings, first class functions and static type inference.

The language and GUI are written in F\#.
\end{abstract}

\chapter{Introduction}\label{ch:intro}

The introduction should be brief and comprise the following:

\section{Project statement}\label{sec:project-statement}


\section{Aims and objectives}\label{sec:aims-and-objectives}

\chapter{Background}\label{ch:background}

\chapter{Development History}\label{ch:devhist}

\section{Sprint 1: Basic expressions}\label{sec:sprint-1:-basic-expressions}

This sprint focused on implementing a lexer and parser for the language, with precedence rules for the arithmetic 
operators, parsed with Pratt parsing.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf1}

\begin{verbatim}
<expr> ::= <term> | <term> "+" <expr> | <term> "-" <expr>
<term> ::= <factor> | <factor> "*" <term> | <factor> "/" <term>
<factor> ::= <number> | "(" <expr> ")"
<number> ::= <int> | <float>
<int> ::= <digit> | <digit> <int>
<float> ::= <int> "." <int>
<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
\end{verbatim}

\section{Sprint 2: Variable assignment}\label{sec:variable-assignment}

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf2}

\begin{verbatim}
<stmtlist> ::= <stmt> | <stmt> <stmtlist>
<stmt> ::= <expr> | "let" <identifier> "=" <expr>

<expr> ::= <term> | <term> "+" <expr> | <term> "-" <expr>
<term> ::= <factor> | <factor> "*" <term> | <factor> "/" <term> | <factor> "%" <term>
<factor> ::= <number> | <identifier> | "(" <expr> ")" | <factor> "^" <factor>

<number> ::= <int> | <float>

<int> ::= <digit> | <digit> <int>
<float> ::= <int> "." <int>
<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<identifier> ::= <letter> | <letter> <identifier>
<letter> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
\end{verbatim}

\section{Sprint 3:; Interpreter}\label{sec:interpreter}

\section{Sprint 4: Functions}\label{sec:functions}

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf3}

\begin{verbatim}
<stmtlist> ::= <stmt> | <stmt> <stmtlist>
<stmt> ::= <expr> | "let" <identifier> "=" <expr>
<expr> ::= <term> | <term> "+" <expr> | <term> "-" <expr>
<term> ::= <factor> | <factor> "*" <term> | <factor> "/" <term> | <factor> "%" <term>
<factor> ::= <number> | <identifier> | "(" <expr> ")" | <factor> "^" <factor> | <identifier> "(" <exprlist> ")" | <lambda>
<lambda> ::= "(" <exprlist> ")" "->" <expr>

<number> ::= <int> | <float>
<int> ::= <digit> | <digit> <int>
<float> ::= <int> "." <int>

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<identifier> ::= <letter> | <letter> <identifier>
<letter> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
<exprlist> ::= <expr> | <expr> "," <exprlist>
	
\end{verbatim}

\section{Sprint 5: Static type checking}\label{sec:static-type-checking}

\section{Sprint 6: Bytecode}\label{sec:bytecode}

\section{Sprint 7: GUI}\label{sec:gui}

\section{Sprint 8: Plotting}\label{sec:plotting1}

\section{Sprint 9: Maths Functions}\label{sec:maths-funcs}

\section{Sprint 9: Optimisation}\label{sec:optimisation1}

\chapter{Final deliverable}\label{ch:impl}

\section{Final BNF}\label{sec:final-bnf}

\section{Final GUI}\label{sec:final-gui}

\section{Lexer}\label{sec:lexer}

Initial lexer design was based on a simple regular expression based lexer, but this was later replaced with a more
functional approach using pattern matching on the input string.

The reason for this change was that the regular expression based lexer was difficult to extend and maintain due to 
the lack of type safety.
For example if we had a more general regex called before a more specific one, the more general one would always match
first, even if the more specific one should have matched.

This was solved by using a more functional approach, where the type system would inform us if a case would never be 
matched due to ordering.

The lexer is now implemented as a recursive pattern matching function that takes a string and returns a list of 
tokens, complete with their lexeme and position in the input string.

Lexer errors are also accumulated in a list of type \textit{LexerError}, which can be displayed to the user in the GUI\@.

Something of note is that the lexer parses numbers itself, rather than passing them to the parser as strings.

\section{Parser}\label{sec:parser}

\section{AST}\label{sec:expression}

The AST of the language is represented as a list of statements, where a statement is either expression, a
variable assignment or an other statement type.

The AST is typed (after type inference\ref{sec:type-inference}) in order to allow for easier optimisation and
bytecode generation.

\section{Type Inference}\label{sec:type-inference}
\input{type-inference}

\section{Optimisation}\label{sec:optimisation}

Before compilation, the AST is optimised by removing dead code and constant folding.

\subsection{Dead code elimination}\label{subsec:dead-code-elimination}

Dead code elimination is performed on the AST by removing any statements that are not used.

For example, if a variable is declared but never used, the variable declaration is removed or if an expression is
calculated but never used, the expression is removed.

This is accomplished by checking every statement in the AST.
If it's an expression node with no side effects, it is removed if it is not used.

If it's a binding node, the rest of the AST is checked for uses of the variable.

If the variable is not used, the binding is removed.

This process is repeated until no more dead code can be removed, allowing for long chains of dead code to be 
removed (for example if a variable is used in a function that is never called, the function would first be removed
and then the variable).

\subsection{Constant folding}\label{subsec:constant-folding}

Constant folding is performed on the AST by evaluating constant expressions at compile time, such as $2 + 2 \ra 4$.

This is accomplished using the initial interpreter implementation, which recursively evaluates the AST and replaces
constant expressions with their evaluated value.

Only constants are evaluated, and thus no variable resolution is performed due to the cost of this operation.

\section{Bytecode Compiler}\label{sec:compiler}

\section{Virtual Machine}\label{sec:virtual-machine}

\section{Plotting}\label{sec:plotting}

\section{Drawing}\label{sec:drawing}

\section{Code architecture}\label{sec:code-architecture}

\chapter{Discussion, conclusion and future work}\label{ch:discussion-conclusion-and-future-work}

\bibliographystyle{apalike}
\bibliography{References}


\appendix
\chapter{Contributions}\label{ch:contributions}

50/50

\chapter{Testing}\label{ch:test}

\section{Lexer testing}\label{sec:lexer-testing}

\section{Parser testing}\label{sec:parser-testing}

\section{Expression testing}\label{sec:arithmetic-expression-testing}

\section{Variable assignment testing}\label{sec:variable-assignment-testing}

\section{Function testing}\label{sec:function-testing}

\section{GUI testing}\label{sec:gui-testing}

\section{Plot testing}\label{sec:plot-testing}

\chapter{Other stuff}\label{ch:other-stuff}

\end{document}

