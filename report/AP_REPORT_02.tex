
\documentclass[a4paper, oneside, 11pt]{report}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{epsfig,pifont,float,multirow,amsmath,amssymb}
\newcommand{\mc}{\multicolumn{1}{c|}}
\newcommand{\mb}{\mathbf}
\newcommand{\mi}{\mathit}
\newcommand{\oa}{\overrightarrow}
\newcommand{\bs}{\boldsymbol}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\usepackage{algorithm}
\usepackage{natbib}
\usepackage{algpseudocode}
\topmargin = 0pt
\voffset = -80pt
\oddsidemargin = 15pt
\textwidth = 425pt
\textheight = 750pt

\begin{document}

\begin{titlepage}
\begin{center}
\rule{12cm}{1mm} \\
\vspace{1cm}
{\large  CMP-6048A Advanced Programming} %Delete as appropriate
\vspace{7.5cm}
\\{\Large Project Report - 13 January 2025}
\vspace{1.5cm}
\\{\LARGE Vec3 Maths Bytecode Interpreter} % You can add to this title of modify it if you wish
\vspace{1.0cm}
\\{\Large Group members: \\ Jamie Wales, Jacob Edwards.\ }
\vspace{10.0cm}
\\{\large School of Computing Sciences, University of East Anglia}
\\ \rule{12cm}{0.5mm}
\\ \hspace{8.5cm} {\large Version 2.0}
\end{center}
\end{titlepage}


\setcounter{page}{1}

\begin{abstract}
Vec3 is a bytecode interpreted maths language complete with a GUI, plotting, full static type inference and various 
maths functions.

The language is designed to be simple to use and understand, with a focus on strict mathematical expressions and 
plotting, but with more powerful constructs such as recursive bindings, first class functions and static type inference.

The language and GUI are written in F\#.
\end{abstract}

\chapter{Introduction}\label{ch:intro}

The introduction should be brief and comprise the following:

\section{Project statement}\label{sec:project-statement}


\section{Aims and objectives}\label{sec:aims-and-objectives}

\chapter{Background}\label{ch:background}

\chapter{Development History}\label{ch:devhist}

\section{Sprint 1: Basic expressions}\label{sec:sprint-1:-basic-expressions}

This sprint focused on implementing a lexer and parser for the language, with precedence rules for the arithmetic 
operators, parsed with Pratt parsing.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf1}

\begin{verbatim}
<expr> ::= <term> | <term> "+" <expr> | <term> "-" <expr>
<term> ::= <factor> | <factor> "*" <term> | <factor> "/" <term>
<factor> ::= <number> | "(" <expr> ")"
<number> ::= <int> | <float>
<int> ::= <digit> | <digit> <int>
<float> ::= <int> "." <int>
<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
\end{verbatim}

\section{Sprint 2: Variable assignment}\label{sec:variable-assignment}

In this sprint we added variable assignment to the language, with the ability to bind an expression to a variable name.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf2}

\begin{verbatim}
<stmtlist> ::= <stmt> | <stmt> <stmtlist>
<stmt> ::= <expr> | "let" <identifier> "=" <expr>

<expr> ::= <term> | <term> "+" <expr> | <term> "-" <expr>
<term> ::= <factor> | <factor> "*" <term> | <factor> "/" <term> | <factor> "%" <term>
<factor> ::= <number> | <identifier> | "(" <expr> ")" | <factor> "^" <factor>

<number> ::= <int> | <float>

<int> ::= <digit> | <digit> <int>
<float> ::= <int> "." <int>
<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<identifier> ::= <letter> | <letter> <identifier>
<letter> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
\end{verbatim}

\section{Sprint 3: Interpreter}\label{sec:interpreter}

In this sprint a basic interpreter was implemented, with the ability to evaluate expressions and variable bindings.

We used a simple environment to store variable bindings, and a recursive evaluation function to evaluate expressions.

It was a REPL style interpreter, where the last expression of a statement list was evaluated and printed.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf3}

\begin{verbatim}
    
\end{verbatim}

\section{Sprint 4: Functions}\label{sec:functions}

In this sprint we added the ability to define and call functions, with a simple lambda syntax of the form 
\texttt{(\textit{args}) -> \textit{expr}} and function calls of the form \texttt{\textit{funcName / lambda}(\textit{args})}.

Call by value semantics were used, with a new environment created for each function call.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf4}

\begin{verbatim}
<stmtlist> ::= <stmt> | <stmt> <stmtlist>
<stmt> ::= <expr> | "let" <identifier> "=" <expr>
<expr> ::= <term> | <term> "+" <expr> | <term> "-" <expr>
<term> ::= <factor> | <factor> "*" <term> | <factor> "/" <term> | <factor> "%" <term>
<factor> ::= <number> | <identifier> | "(" <expr> ")" | <factor> "^" <factor> | <identifier> "(" <exprlist> ")" | <lambda>
<lambda> ::= "(" <exprlist> ")" "->" <expr> 

<number> ::= <int> | <float>
<int> ::= <digit> | <digit> <int>
<float> ::= <int> "." <int>

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<identifier> ::= <letter> | <letter> <identifier>
<letter> ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
<exprlist> ::= <expr> | <expr> "," <exprlist>
	
\end{verbatim}

\section{Sprint 5: Static type checking}\label{sec:static-type-checking}

In this sprint we added static type checking to the language, with a simple type inference system based on 
Hindley-Milner.

The concept of types was introduced, with the types \texttt{Int}, \texttt{Float}, \texttt{Bool}, \texttt{Function} and
\texttt{Never}.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf5}

\begin{verbatim}
\end{verbatim}

\section{Sprint 6: Bytecode}\label{sec:bytecode}

In this sprint the interpreter was rewritten to use a bytecode interpreter, with a stack based virtual machine as 
well as a simple bytecode compiler, allowing for more efficient evaluation of expressions.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf6}

\begin{verbatim}
\end{verbatim}

\section{Sprint 7: GUI}\label{sec:gui}

A simple GUI was developed in order to allow easier testing of the language, with a text box for input and output and a 
decompiler output for debugging.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf7}

\begin{verbatim}
\end{verbatim}

\section{Sprint 8: Plotting}\label{sec:plotting1}

In this sprint we added the ability to plot lists of points, with a simple plotting function that took a list of
\textit{x} coordinates and a list of \textit{y} coordinates and plotted them on a graph using \citet{scottPlot}.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf8}

\begin{verbatim}
\end{verbatim}

\section{Sprint 9: Maths Functions}\label{sec:maths-funcs}

In this sprint we added a number of maths functions to the language, including \texttt{sin}, \texttt{cos}, \texttt{tan},
\texttt{asin}, \texttt{acos} and others, and added the ability to plot functions, both built in and user defined.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf9}

\begin{verbatim}
\end{verbatim}

\section{Sprint 9: Optimisation}\label{sec:optimisation1}

In this sprint we added a simple optimisation pass to the bytecode compiler, which removed unnecessary stack operations
and combined constant expressions.

\subsection{Grammar in BNF}\label{subsec:grammar-in-bnf10}

\begin{verbatim}
\end{verbatim}

\chapter{Final deliverable}\label{ch:impl}

\input{final-deliverable}

\chapter{Discussion, conclusion and future work}\label{ch:discussion-conclusion-and-future-work}

\bibliographystyle{apalike}
\bibliography{References}


\appendix
\chapter{Contributions}\label{ch:contributions}

50/50

\chapter{Testing}\label{ch:test}

\section{Lexer testing}\label{sec:lexer-testing}

\section{Parser testing}\label{sec:parser-testing}

\section{Expression testing}\label{sec:arithmetic-expression-testing}

\section{Variable assignment testing}\label{sec:variable-assignment-testing}

\section{Function testing}\label{sec:function-testing}

\section{GUI testing}\label{sec:gui-testing}

\section{Plot testing}\label{sec:plot-testing}

\chapter{Other stuff}\label{ch:other-stuff}

\end{document}

