The core of the Vec3 interpreter was a transition from a tree-walk interpreter to a more efficient stack-based virtual machine. 
This involved two primary components: a compiler to translate Vec3 source code into bytecode, and a virtual machine to execute that bytecode. 
The fundamental goal was to achieve faster execution speeds by working with a compact and streamlined instruction set.

The bytecode itself was a sequence of instructions, each represented by an operation code (opcode) and, potentially, operands that the opcode would act upon. 
These opcodes, defined in the \texttt{OP\_CODE} type, covered a range of operations necessary for a fully functional language. 
This included instructions for pushing constants onto the stack (\texttt{CONSTANT}, \texttt{CONSTANT\_LONG}), performing arithmetic (\texttt{ADD}, \texttt{SUBTRACT}, \texttt{MULTIPLY}, \texttt{DIVIDE}, \texttt{NEGATE}), managing control flow (\texttt{RETURN}, \texttt{JUMP}, \texttt{JUMP\_IF\_FALSE}, \texttt{LOOP}), handling boolean logic (\texttt{NIL}, \texttt{TRUE}, \texttt{FALSE}, \texttt{NOT}, \texttt{EQUAL}, \texttt{GREATER}, \texttt{LESS}), manipulating the stack (\texttt{POP}), working with global and local variables (\texttt{DEFINE\_GLOBAL}, \texttt{GET\_GLOBAL}, \texttt{SET\_GLOBAL}, \texttt{GET\_LOCAL}, \texttt{SET\_LOCAL}), outputting values (\texttt{PRINT}), and calling functions (\texttt{CALL}). Two functions, \texttt{opCodeToByte} and \texttt{byteToOpCode}, handled the conversion between these symbolic opcodes and their corresponding byte representations, ensuring a compact bytecode format.

Compiled code, along with associated data, was organized into \texttt{Chunk} structures. 
Each chunk contained a \texttt{Code} array, holding the bytecode instructions as a sequence of bytes. 
A \texttt{ConstantPool} array stored constant values referenced by the instructions, enabling efficient reuse of values like numbers and strings. 
To aid in debugging, a \texttt{Lines} array mapped bytecode offsets to their corresponding line numbers in the original source code. 
Functions like \texttt{emptyChunk}, \texttt{writeChunk}, \texttt{addConstant}, \texttt{writeConstant}, and \texttt{getLineNumber} provided an interface for creating and manipulating chunks.

The compiler's role was to transform the abstract syntax tree (AST) representation of Vec3 code into this bytecode format. 
It maintained a \texttt{CompilerState} to track the chunk being generated, local variables within the current scope, the current scope's nesting depth, and the line number being processed. 
The compilation process involved a recursive descent through the AST. Functions like \texttt{compileStmt} and \texttt{compileExpr} recursively processed statements and expressions, respectively. 
For each AST node encountered, the compiler emitted corresponding bytecode instructions using helper functions like \texttt{emitByte}, \texttt{emitBytes}, \texttt{emitConstant}, and \texttt{emitOpCode}.

Variable declarations were handled by \texttt{compileVariableDeclaration}, which added the variable to the \texttt{Locals} map in the \texttt{CompilerState}. 
This map stored local variables and their corresponding slot indices on the virtual machine's stack. 
Control flow instructions, like jumps and loops, were initially emitted with placeholder offsets. 
These placeholders were later patched with the correct offsets once the target locations were determined.

\paragraph{Error Handling}
Error handling during compilation was managed using the \texttt{CompilerResult} type. 
This allowed the compiler to either return a successful result along with an updated \texttt{CompilerState} or an error along with a descriptive message and the state at the point of the error.

\paragraph{Debugging}
To facilitate debugging, a disassembler was implemented. 
Functions like \texttt{disassembleInstruction} and \texttt{disassembleChunk} took the compiled bytecode and produced a human-readable representation, showing the instructions, their operands, and their associated source code line numbers. 
This was invaluable for understanding the generated bytecode and identifying potential issues.